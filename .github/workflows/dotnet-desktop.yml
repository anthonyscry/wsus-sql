# WSUS-SQL CI/CD Pipeline
# Builds the WPF GUI application and runs PowerShell code analysis

name: WSUS-SQL CI/CD

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Enable verbose debugging output'
        required: false
        default: 'false'
        type: boolean

env:
  DOTNET_VERSION: '6.0.x'
  PROJECT_PATH: 'GUI/WsusManager.csproj'

jobs:
  # PowerShell Code Review and Security Checks
  powershell-analysis:
    name: PowerShell Analysis
    runs-on: windows-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Install PSScriptAnalyzer
      shell: pwsh
      run: |
        Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser

    - name: Run PSScriptAnalyzer - Code Quality
      shell: pwsh
      run: |
        $results = Invoke-ScriptAnalyzer -Path . -Recurse -ExcludeRule PSAvoidUsingWriteHost -Severity Warning,Error

        if ($results) {
          Write-Host "## PSScriptAnalyzer Results" -ForegroundColor Yellow
          $results | Format-Table -Property RuleName, Severity, ScriptName, Line, Message -AutoSize -Wrap

          $errors = $results | Where-Object { $_.Severity -eq 'Error' }
          if ($errors) {
            Write-Host "::error::Found $($errors.Count) error-level issues"
            exit 1
          }

          Write-Host "::warning::Found $($results.Count) warnings (non-blocking)"
        } else {
          Write-Host "No issues found!" -ForegroundColor Green
        }

    - name: Run PSScriptAnalyzer - Security Rules
      shell: pwsh
      run: |
        $securityRules = @(
          'PSAvoidUsingPlainTextForPassword',
          'PSAvoidUsingConvertToSecureStringWithPlainText',
          'PSAvoidUsingUsernameAndPasswordParams',
          'PSUsePSCredentialType',
          'PSAvoidUsingInvokeExpression'
        )

        $results = Invoke-ScriptAnalyzer -Path . -Recurse -IncludeRule $securityRules

        if ($results) {
          Write-Host "## Security Analysis Results" -ForegroundColor Red
          $results | Format-Table -Property RuleName, Severity, ScriptName, Line, Message -AutoSize -Wrap
          Write-Host "::error::Found $($results.Count) security issues"
          exit 1
        } else {
          Write-Host "No security issues found!" -ForegroundColor Green
        }

    - name: Check for Hardcoded Secrets
      shell: pwsh
      run: |
        $patterns = @(
          'password\s*=\s*[''"][^''"]+[''"]',
          'apikey\s*=\s*[''"][^''"]+[''"]',
          'secret\s*=\s*[''"][^''"]+[''"]',
          'connectionstring.*password',
          'ConvertTo-SecureString.*-AsPlainText'
        )

        $issues = @()
        Get-ChildItem -Path . -Recurse -Include *.ps1,*.psm1,*.psd1 | ForEach-Object {
          $content = Get-Content $_.FullName -Raw -ErrorAction SilentlyContinue
          if ($content) {
            foreach ($pattern in $patterns) {
              if ($content -match $pattern) {
                $issues += [PSCustomObject]@{
                  File = $_.FullName
                  Pattern = $pattern
                }
              }
            }
          }
        }

        if ($issues) {
          Write-Host "## Potential Hardcoded Secrets Found" -ForegroundColor Red
          $issues | Format-Table -AutoSize
          Write-Host "::warning::Found potential hardcoded secrets - please review manually"
        } else {
          Write-Host "No hardcoded secrets detected!" -ForegroundColor Green
        }

    - name: Validate Module Structure
      shell: pwsh
      run: |
        $modules = Get-ChildItem -Path ./Modules -Filter *.psm1 -ErrorAction SilentlyContinue

        if ($modules) {
          Write-Host "## Module Validation" -ForegroundColor Cyan
          foreach ($module in $modules) {
            Write-Host "Validating: $($module.Name)"
            try {
              # Initialize variables before using with [ref]
              $tokens = $null
              $errors = $null
              $null = [System.Management.Automation.Language.Parser]::ParseFile($module.FullName, [ref]$tokens, [ref]$errors)
              if ($errors) {
                Write-Host "  Parse errors found:" -ForegroundColor Red
                $errors | ForEach-Object { Write-Host "    $_" }
                exit 1
              } else {
                Write-Host "  Syntax OK" -ForegroundColor Green
              }
            } catch {
              Write-Host "  Failed to parse: $_" -ForegroundColor Red
              exit 1
            }
          }
        }

    - name: List Module Exported Functions
      shell: pwsh
      run: |
        Write-Host "## Module Function Inventory" -ForegroundColor Cyan
        $modules = Get-ChildItem -Path ./Modules -Filter *.psm1 -ErrorAction SilentlyContinue

        foreach ($module in $modules) {
          Write-Host "`n$($module.BaseName):" -ForegroundColor Yellow
          $content = Get-Content $module.FullName -Raw
          $functions = [regex]::Matches($content, 'function\s+([\w-]+)')
          $functions | ForEach-Object { Write-Host "  - $($_.Groups[1].Value)" }
          Write-Host "  Total: $($functions.Count) functions"
        }

    - name: Upload Analysis Results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: powershell-analysis-results
        path: |
          **/*.ps1
          **/*.psm1
        retention-days: 7

  # Build the WPF GUI Application
  build-gui:
    name: Build GUI Application
    runs-on: windows-latest
    needs: powershell-analysis

    strategy:
      matrix:
        configuration: [Debug, Release]

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Install .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Display .NET Info
      run: |
        dotnet --info
        dotnet --list-sdks

    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}

    - name: Build
      run: |
        dotnet build ${{ env.PROJECT_PATH }} --configuration ${{ matrix.configuration }} --no-restore -v normal
      continue-on-error: false

    - name: Build Diagnostics
      if: failure()
      shell: pwsh
      run: |
        Write-Host "## Build Failed - Diagnostic Information" -ForegroundColor Red
        Write-Host "`n### Project File Contents:" -ForegroundColor Yellow
        Get-Content GUI/WsusManager.csproj

        Write-Host "`n### Directory Structure:" -ForegroundColor Yellow
        Get-ChildItem -Path GUI -Recurse -Name | ForEach-Object { Write-Host "  $_" }

        Write-Host "`n### NuGet Package Cache:" -ForegroundColor Yellow
        dotnet nuget locals all --list

    - name: Publish Self-Contained
      if: matrix.configuration == 'Release'
      run: |
        dotnet publish ${{ env.PROJECT_PATH }} -c Release -r win-x64 --self-contained true -p:PublishSingleFile=true -p:IncludeNativeLibrariesForSelfExtract=true -o ./publish

    - name: Verify Published Executable
      if: matrix.configuration == 'Release'
      shell: pwsh
      run: |
        Write-Host "## Build Verification" -ForegroundColor Green

        $exe = Get-Item "./publish/WsusManager.exe" -ErrorAction SilentlyContinue
        if ($exe) {
          $sizeMB = [math]::Round($exe.Length / 1MB, 2)
          Write-Host "Executable: WsusManager.exe"
          Write-Host "Size: $sizeMB MB"
          Write-Host "Created: $($exe.CreationTime)"
          Write-Host "Modified: $($exe.LastWriteTime)"

          # Verify it's a valid PE file
          $bytes = [System.IO.File]::ReadAllBytes($exe.FullName)
          if ($bytes[0] -eq 0x4D -and $bytes[1] -eq 0x5A) {
            Write-Host "PE Header: Valid (MZ signature found)" -ForegroundColor Green
          } else {
            Write-Host "::error::Invalid PE header - executable may be corrupted"
            exit 1
          }
        } else {
          Write-Host "::error::WsusManager.exe not found in publish directory"
          exit 1
        }

        Write-Host "`n### Published Files:" -ForegroundColor Yellow
        Get-ChildItem ./publish | Format-Table Name, Length, LastWriteTime

    - name: Create Release Package
      if: matrix.configuration == 'Release'
      shell: pwsh
      run: |
        # Create package directory
        $packageDir = "./package"
        New-Item -ItemType Directory -Path $packageDir -Force | Out-Null

        # Copy executable
        Copy-Item "./publish/WsusManager.exe" $packageDir

        # Copy PowerShell modules
        Copy-Item -Path "./Modules" -Destination "$packageDir/Modules" -Recurse

        # Copy main scripts
        Copy-Item "./Invoke-WsusManagement.ps1" $packageDir
        Copy-Item -Path "./Scripts" -Destination "$packageDir/Scripts" -Recurse

        # Create version info file
        $versionInfo = @(
          "WSUS Manager Package",
          "====================",
          "Build Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')",
          "Git SHA: $env:GITHUB_SHA",
          "Git Ref: $env:GITHUB_REF",
          "Runner: $env:RUNNER_OS",
          "",
          "Contents:",
          "- WsusManager.exe: GUI application (self-contained, no .NET runtime required)",
          "- Modules/: PowerShell modules for WSUS operations",
          "- Scripts/: Standalone PowerShell scripts",
          "- Invoke-WsusManagement.ps1: Main CLI entry point"
        ) -join "`n"
        $versionInfo | Out-File "$packageDir/BUILD_INFO.txt"

        Write-Host "Package created successfully"
        Get-ChildItem $packageDir -Recurse | Format-Table FullName, Length

    - name: Upload Build Artifacts
      if: matrix.configuration == 'Release'
      uses: actions/upload-artifact@v4
      with:
        name: WsusManager-${{ matrix.configuration }}
        path: ./publish/

    - name: Upload Complete Package
      if: matrix.configuration == 'Release'
      uses: actions/upload-artifact@v4
      with:
        name: WsusManager-Complete-Package
        path: ./package/
        retention-days: 30

  # Summary job for debugging
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [powershell-analysis, build-gui]
    if: always()

    steps:
    - name: Generate Summary
      run: |
        echo "## WSUS-SQL CI/CD Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| PowerShell Analysis | ${{ needs.powershell-analysis.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| GUI Build | ${{ needs.build-gui.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "- **WsusManager-Release**: Self-contained executable" >> $GITHUB_STEP_SUMMARY
        echo "- **WsusManager-Complete-Package**: Full distribution package with scripts and modules" >> $GITHUB_STEP_SUMMARY
