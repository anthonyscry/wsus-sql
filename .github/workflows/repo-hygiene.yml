name: Repository Hygiene

on:
  schedule:
    - cron: "0 2 * * *"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  cleanup:
    name: Cleanup stale PRs, branches, and workflow runs
    runs-on: ubuntu-latest
    steps:
      - name: Run repository hygiene cleanup
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // ============================
            // Global configuration (tune these values)
            // ============================
            const PR_INACTIVITY_HOURS = 24; // Close PRs with no activity beyond this threshold
            const BRANCH_AGE_DAYS = 7; // Delete branches older than this threshold
            const WORKFLOW_MAX_RUNTIME_MINUTES = 45; // Delete workflow runs exceeding this runtime
            const SAFE_MODE = true; // true = log only, false = perform destructive actions
            const PROTECTED_PR_LABELS = new Set(["keep", "do-not-close", "wip"]);
            const PROTECTED_BRANCH_NAMES = new Set(["main", "master", "develop"]);
            const PROTECTED_BRANCH_PREFIXES = ["release/", "hotfix/", "keep/"];

            const { owner, repo } = context.repo;
            const triggerActor = context.actor;

            const now = new Date();
            const msFromHours = (hours) => hours * 60 * 60 * 1000;
            const msFromDays = (days) => days * 24 * 60 * 60 * 1000;
            const isProtectedPrefix = (branchName) =>
              PROTECTED_BRANCH_PREFIXES.some((prefix) => branchName.startsWith(prefix));

            const safeLogAction = (message) => {
              core.info(`[SAFE_MODE=${SAFE_MODE}] ${message}`);
            };

            // ============================
            // 1) Pull request cleanup
            // ============================
            core.info("=== Pull Request Cleanup ===");
            const prStaleCutoff = new Date(now.getTime() - msFromHours(PR_INACTIVITY_HOURS));
            core.info(`PR inactivity threshold: ${PR_INACTIVITY_HOURS} hour(s) (cutoff: ${prStaleCutoff.toISOString()})`);
            core.info(`Trigger actor: ${triggerActor}`);

            for await (const response of github.paginate.iterator(
              github.rest.pulls.list,
              { owner, repo, state: "open", per_page: 100 }
            )) {
              for (const pr of response.data) {
                const prLabels = pr.labels.map((label) => label.name);
                const hasProtectedLabel = prLabels.some((label) => PROTECTED_PR_LABELS.has(label));
                const isDraft = pr.draft === true;
                const isMerged = Boolean(pr.merged_at);
                const isAuthoredByTrigger = pr.user?.login === triggerActor;
                const lastActivity = new Date(pr.updated_at);
                const isInactive = lastActivity < prStaleCutoff;

                core.info(`PR #${pr.number}: draft=${isDraft}, merged=${isMerged}, actorMatch=${isAuthoredByTrigger}, updated=${pr.updated_at}, labels=[${prLabels.join(", ")}]`);

                if (isMerged) {
                  core.info(`Skipping PR #${pr.number}: already merged.`);
                  continue;
                }
                if (isDraft) {
                  core.info(`Skipping PR #${pr.number}: draft PR.`);
                  continue;
                }
                if (!isAuthoredByTrigger) {
                  core.info(`Skipping PR #${pr.number}: author does not match trigger actor.`);
                  continue;
                }
                if (hasProtectedLabel) {
                  core.info(`Skipping PR #${pr.number}: protected label present.`);
                  continue;
                }
                if (!isInactive) {
                  core.info(`Skipping PR #${pr.number}: recent activity.`);
                  continue;
                }

                const commentBody = [
                  "This PR was automatically closed due to inactivity.",
                  `No activity was detected in the last ${PR_INACTIVITY_HOURS} hour(s).`,
                  "If this was closed in error, please reopen and continue the work."
                ].join("\n");

                if (SAFE_MODE) {
                  safeLogAction(`Would comment and close PR #${pr.number}.`);
                  continue;
                }

                core.info(`Commenting on PR #${pr.number}.`);
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pr.number,
                  body: commentBody
                });

                core.info(`Closing PR #${pr.number}.`);
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: pr.number,
                  state: "closed"
                });
              }
            }

            // ============================
            // 2) Branch cleanup
            // ============================
            core.info("=== Branch Cleanup ===");
            const branchStaleCutoff = new Date(now.getTime() - msFromDays(BRANCH_AGE_DAYS));
            core.info(`Branch age threshold: ${BRANCH_AGE_DAYS} day(s) (cutoff: ${branchStaleCutoff.toISOString()})`);

            const openPrBranches = new Set();
            const branchNames = new Set();
            for await (const response of github.paginate.iterator(
              github.rest.pulls.list,
              { owner, repo, state: "open", per_page: 100 }
            )) {
              for (const pr of response.data) {
                if (pr.head?.ref) {
                  openPrBranches.add(pr.head.ref);
                }
              }
            }

            for await (const response of github.paginate.iterator(
              github.rest.repos.listBranches,
              { owner, repo, per_page: 100 }
            )) {
              for (const branch of response.data) {
                const branchName = branch.name;
                branchNames.add(branchName);
                core.info(`Branch: ${branchName}`);

                if (PROTECTED_BRANCH_NAMES.has(branchName)) {
                  core.info(`Skipping branch ${branchName}: protected branch name.`);
                  continue;
                }
                if (isProtectedPrefix(branchName)) {
                  core.info(`Skipping branch ${branchName}: protected branch prefix.`);
                  continue;
                }
                if (openPrBranches.has(branchName)) {
                  core.info(`Skipping branch ${branchName}: has open PR.`);
                  continue;
                }

                const commitDate = new Date(branch.commit.committer?.date || branch.commit.commit?.committer?.date);
                if (Number.isNaN(commitDate.getTime())) {
                  core.info(`Skipping branch ${branchName}: unable to determine last commit date.`);
                  continue;
                }

                core.info(`Branch ${branchName} last commit: ${commitDate.toISOString()}`);

                if (commitDate >= branchStaleCutoff) {
                  core.info(`Skipping branch ${branchName}: recent commit.`);
                  continue;
                }

                if (SAFE_MODE) {
                  safeLogAction(`Would delete branch ${branchName}.`);
                  continue;
                }

                core.info(`Deleting branch ${branchName}.`);
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: `heads/${branchName}`
                });
              }
            }

            // ============================
            // 3) Workflow runtime cleanup
            // ============================
            core.info("=== Workflow Runtime Cleanup ===");
            core.info(`Workflow runtime threshold: ${WORKFLOW_MAX_RUNTIME_MINUTES} minute(s).`);

            for await (const response of github.paginate.iterator(
              github.rest.actions.listWorkflowRunsForRepo,
              { owner, repo, per_page: 100 }
            )) {
              for (const run of response.data.workflow_runs || []) {
                const status = run.status;
                const conclusion = run.conclusion;
                const ref = run.head_branch;
                const event = run.event;
                const runId = run.id;
                const runName = run.name;
                const runUrl = run.html_url;

                if (status !== "completed") {
                  core.info(`Skipping run ${runId}: status=${status} (active run).`);
                  continue;
                }
                if (event === "release") {
                  core.info(`Skipping run ${runId}: release event.`);
                  continue;
                }
                if (ref && !branchNames.has(ref)) {
                  core.info(`Skipping run ${runId}: head branch '${ref}' not found in branch list (likely tag run).`);
                  continue;
                }

                const startedAt = run.run_started_at ? new Date(run.run_started_at) : null;
                const updatedAt = run.updated_at ? new Date(run.updated_at) : null;

                if (!startedAt || !updatedAt) {
                  core.info(`Skipping run ${runId}: missing timestamps.`);
                  continue;
                }

                const runtimeMinutes = Math.round((updatedAt - startedAt) / 60000);
                core.info(`Run ${runId} (${runName}) status=${status} conclusion=${conclusion} branch=${ref} runtime=${runtimeMinutes}m url=${runUrl}`);

                if (runtimeMinutes <= WORKFLOW_MAX_RUNTIME_MINUTES) {
                  core.info(`Skipping run ${runId}: runtime within threshold.`);
                  continue;
                }

                if (SAFE_MODE) {
                  safeLogAction(`Would delete workflow run ${runId} (runtime=${runtimeMinutes}m).`);
                  continue;
                }

                core.info(`Deleting workflow run ${runId}.`);
                await github.rest.actions.deleteWorkflowRun({
                  owner,
                  repo,
                  run_id: runId
                });
              }
            }
